<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>计算机网络 | 春风少年兄</title><meta name=keywords content><meta name=description content="欢迎来到世纪大道"><meta name=author content="Me"><link rel=canonical href=https://blog.0pt.im/zh/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.4b652714b710c7fd948e965adf64e815b9d09f68a358365c02ac09b95e5516be.css integrity="sha256-S2UnFLcQx/2UjpZa32ToFbnQn2ijWDZcAqwJuV5VFr4=" rel="preload stylesheet" as=style><link rel=icon href=https://img.0pt.im/blogbuilt/title.jpeg><link rel=icon type=image/png sizes=16x16 href=https://img.0pt.im/blogbuilt/title.jpeg><link rel=icon type=image/png sizes=32x32 href=https://img.0pt.im/blogbuilt/title.jpeg><link rel=apple-touch-icon href=https://img.0pt.im/blogbuilt/title.jpeg><link rel=mask-icon href=https://img.0pt.im/blogbuilt/title.jpeg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.0pt.im/zh/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="计算机网络"><meta property="og:description" content="欢迎来到世纪大道"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.0pt.im/zh/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><meta property="og:image" content="https://blog.0pt.im/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="春风少年兄"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.0pt.im/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="计算机网络"><meta name=twitter:description content="欢迎来到世纪大道"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.0pt.im/zh/ accesskey=h title="世纪大道 (Alt + H)"><img src=https://blog.0pt.im/apple-touch-icon.png alt aria-label=logo height=35>世纪大道</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.0pt.im/zh/search title=找><span>找</span></a></li><li><a href=https://blog.0pt.im/zh/learn/ title=学><span>学</span></a></li><li><a href=https://blog.0pt.im/zh/music/ title=音><span>音</span></a></li><li><a href=https://blog.0pt.im/zh/game/ title=游><span>游</span></a></li><li><a href=https://blog.0pt.im/zh/think/ title=感><span>感</span></a></li><li><a href=https://blog.0pt.im/zh/link/ title=链><span>链</span></a></li><li><a href=https://blog.0pt.im/zh/archives title=时><span>时</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://blog.0pt.im/zh/>主页</a>&nbsp;»&nbsp;<a href=https://blog.0pt.im/zh/tags/>Tags</a></div><h1>计算机网络
<a href=/zh/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.xml title=RSS aria-label=RSS><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>从零开始的计算机网络3-6</h2></header><div class=entry-content><p>媒体接入控制的基本概念 共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC(Medium Access Control)。
随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。
静态划分信道 信道复用
复用(Multiplexing）是通信技术中的一个重要概念。复用就是通过一条物理线路同时传输多路用户的信号。
当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。
1.频分复用FDM
频分复用的所有用户同时占用不同的频带资源并行通信。
2.时分复用TDM
时分复用的所有用户在不同的时间占用同样的频带宽度。
3.波分复用（光的频分复用）
4.码分复用
码分复用CDM是另一种共享信道的方法。实际上，由于该技术主要用于多址接入，人们更常用的名词是码分多址CDMA(Code Division Multiple Access)。
同理，频分复用FDM和时分复用TDM同样可用于多址接入，相应的名词是频分多址FDMA(Frequency Division Multiple Access)和时分多址TDMA(Time Division Multiple Access)。在本课程中，我们不严格区分复用与多址的概念。可简单理解如下:
复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分。
多址（更确切地应该称为多点接入）处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久性地分配给用户的应用中，多址是不需要的(对于无线广播或电视广播站就是这样)。
某种程度上，FDMA、TDMA、CDMA可以分别看成是FDM、TDM、CDM的应用。
与FDM和TDM不同，CDM的每一个用户可以在同样的时间使用同样的频带进行通信。由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。
CDM最初是用于军事通信的，因为这种系统所发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。
随着技术的进步，CDMA设备的价格和体积都大幅度下降，因而现在已广泛用于民用的移动通信中。
在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片(Chip)。通常m的值是64或128。为了简单起见，在后续的举例中，我们假设m为8。
使用CDMA的每一个站被指派一个唯一的m bit码片序列(Chip Sequence)
一个站如果要发送比特1，则发送它自己的m bit码片序列;
一个站如果要发送比特0，则发送它自己的m bit码片序列的二进制反码;
例：指派给CDMA系统中某个站点的码片序列为00011011
发送比特1:发送自己的码片序列00011011
发送比特0:发送自己的码片序列的二进制反码11100100
为了方便，我们按惯例将码片序列中的0写为-1，将1写为+1。
则该站点的码片序列是(-1 -1 -1 +1 +1 -1 +1 +1)。
这种通信方式称为直接序列扩频，DSSS。
码片序列的挑选原则如下:
分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列。
分配给每个站的码片序列必须相互正交(规格化内积为0)。正交就是向量互相垂直。
令向量S表示站S的码片序列，令向量T表示其他任何站的码片序列。两个不同站S和T的码片序列正交，就是向量S和T的规格化内积为0:
向量S相当于m维向量。
例题：共有4个站进行CDMA通信，这4个站的码片序列分别为:
A: (-1 -1-1 +1 +1 -1+1 +1) B: (-1 -1+1-1+1 +1 +1-1)...</p></div><footer class=entry-footer><span title='2023-07-16 18:09:28 +0800 CST'>七月 16, 2023</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;279 字&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 从零开始的计算机网络3-6" href=https://blog.0pt.im/learn/1-3-6/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>从零开始的计算机网络3-5</h2></header><div class=entry-content><p>点对点协议PPP 点对点协议PPP(Point-to-Point Protocol)是目前使用最广泛的点对点数据链路层协议。
PPP协议是因特网工程任务组IETF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661,RFC1662]。
用户连接到ISP就是通过PPP协议。
PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成:
对各种协议数据报的封装方法（封装成帧）
链路控制协议LCP，用于建立、配置以及测试数据链路的连接
一套网络控制协议NCPs，其中的每一个协议支持不同的网络层协议
帧格式 标志（Flag）字段: PPP帧的定界符，取值为0x7E
地址（Address）字段:取值为OxFF，预留（目前没有什么作用）
控制(Control)字段:取值为Ox03，预留（目前没有什么作用）
协议(Protocol）字段:指明帧的数据部分送交哪个协议处理
取值Ox0021表示:帧的数据部分为IP数据报
取值OxC021表示:帧的数据部分为LCP分组
取值0x8021表示:帧的数据部分为NCP分组
帧检验序列（Frame Check Sequence）字段:CRC计算出的校验位
透明传输 面向字节的异步链路采用插入转义字符的字节填充法
发送方的处理：
出现的每一个7E(PPP帧的定界符）字节转变成2字节序列(7D,5E)。
出现的每一个7D(转义字符)字节转变成2字节序列(7D,5D)。
出现的每一个ASCII码控制字符（数值小于0x20的字符)，则在该字符前面插入一个7D字节，同时将该字符的编码加上0x20。
接收方的处理：进行反变换即可恢复出原来的帧的数据部分。
面向比特的同步链路采用插入比特0的比特填充法
发送方的处理:
对帧的数据部分进行扫描（一般由硬件实现)。只要发现5个连续的比特1，则立即填充1个比特0。
接收方的处理:
对帧的数据部分进行扫描（一般由硬件实现)。只要发现5个连续的比特1，就把其后的1个比特0删除。
差错检测 RFC 1662的附录部分给出了FCS的计算方法的C语言实现(查表法)
接收方每收到一个PPP帧，就进行CRC检验。若CRC检验正确，就收下这个帧;反之，就丢弃这个帧。使用PPP的数据链路层向上不提供可靠传输服务。
工作状态 PPP链路的两端互相交换网络层特定的NCP分组。
如果在PPP链路上运行的是IP，则使用IP控制协议IPCP来对PPP链路的每一端配置P模块(如分配IP地址)。</p></div><footer class=entry-footer><span title='2023-07-15 18:09:28 +0800 CST'>七月 15, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;40 字&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 从零开始的计算机网络3-5" href=https://blog.0pt.im/learn/1-3-5/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>从零开始的计算机网络3-4</h2></header><div class=entry-content><p>可靠传输 基本概念 使用差错检测技术（例如循环冗余校验CRC），接收方的数据链路层就可检测传输过程中是否产生了误码（比特错误）。
数据链路层向上层提供的服务类型
不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做;
可靠传输服务：想办法实现发送端发送什么，接收端就收到什么。
一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。
无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。
比特差错只是传输差错中的一种。
从整个计算机网络体系结构来看，传输差错还包括分组丢失（发送的分组因某种原因被丢弃）、分组失序（发送的多个分组到达接收方的顺序与发送时不同）以及分组重复（分组因网络延时卡在路由器，引发发送方的超时发送，出现重复）。
分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。
可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需。
可靠传输的实现机制——停止-等待协议SW(Stop-and-Wait) 1.确认与否认
DATA为数据分组，ACK为确认分组，NAK为否认分组。从上往下。
如该图，接收方发送第一个DATA，接收方对其进行差错，确认无误码，返回ACK，发送方收到ACK后，才可以删除第一个DATA的缓存，发送第二个DATA，若第二个DATA在传输过程中出现误码，接收方对其进行差错，返回NAK，发送方收到NAK，重新发送第二个DATA。（这就是为什么只有收到ACk时才能删除那个数据分组的缓存。）
2.超时重传
接收方收不到数据分组，就不会发送ACK或NAK。如果不采取其他措施，发送方就会一直处于等待接收方ACK或NAK的状态。
为解决该问题，可以在发送方发送完一个数据分组时，启动一个超时计时器。若到了超时计时器所设置的重传时间而发送方仍收不到接收方的任何ACK或NAK，则重传原来的数据分组，这就叫做超时重传。
一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”
3.确认分组丢失
ACK丢失，会引起发送方的超时重传。
为避免分组重复这种传输错误，必须给每个分组带上序号。（如图，DATA0，DATA1）
对于停止-等待协议，由于每发送一个数据分组就停止等待,只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同就可以了，因此用一个比特来编号就够了。
4.确认分组迟到
对确认分组（ACK）进行编号。
ACK0迟到了，导致发送方超时重传，接收方接收到超时重传的DATA0，将其丢弃，并再发送ACK0，发送方接收到重复的ACK0，忽略该确认分组。
对于数据链路层的点对点信道，往返时间比较固定，不会出现确认分组迟到的情况，因此只在数据链路层实现停止等待协议，不需要给ACK编码。
注意事项：
1.接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组
2.为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。
3.为了让发送方能够判断所收到的ACK分组是否是重复的，需要给ACK分组编号，所用比特数量与数据分组编号所用比特数量一样。数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。
4.超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。
在数据链路层点对点的往返时间比较确定，重传时间比较好设定。
然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。
信道利用率
当往返时延RTT远大于数据帧发送时延To时（例如使用卫星链路)，信道利用率非常低。
若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低。
为了克服停止-等待协议信道利用率很低的缺点，就产生了另外两种协议，即后退N帧协议GBN和选择重传协议SR。
例题：主机甲采用停-等协议向主机乙发送数据，数据传输速率使3kbps，单向传播延时是200ms,忽略确认帧的传输延时。当信道利用率等于40%时，数据帧的长度为
A.240比特 B.400比特 C.480比特 D.800比特
解析：
可靠传输的实现机制——回退N帧协议GBN(Go-Back-N) 采用流水线传输可提高信道利用率。
1.采用3个比特给分组编序号，即序号0~7; n个比特， 0~2^n -1
2.发送窗口的尺寸Wt的取值:1&lt;Wt≤2^3 - 1，本例取Wt=5. 1&lt;Wr&lt;2^n -1
3.接收窗口的尺寸Wr的取值:Wr=1;
发送窗口一次发送5个
到达接收方，接收窗口依次一个分组一个分组识别，并依次发回确认分组。
发送方每接受一个确认分组，发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口。
发送方可以把收到确认的分组从缓存中删除了，而接收方可以择机将已接收的数据交付上层处理。
累积确认
接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后（由具体实现决定)对按序到达的最后一个数据分组发送确认。ACKn表示序号为n及以前的所有数据分组都已正确接收。
如上图，接收方接收到0-1，发送一个ACK1，处理完2-4，发送一个ACK4，若ACK1丢了，ACK4到达发送方，则表明分组0-4都确认，已正确接收。
缺点
5号出现误码，丢弃，而后的序号6701，无法被5号接收窗口接收，也只能丢弃，每丢弃一个数据分组（5号误码不算），返回之前按序接受的最后一个确认分组，在本例中是ACK4，发4个ACK4。
发送方收到重复的确认。就知道之前所发送的数据分组出现了差错,于是可以不等超时计时器超时就立刻重传!
至于收到几个重复确认就立刻重传,由具体实现决定。若不能触发立刻重传，则等待超时计时器。超时后将发送窗口中的分组重传。
在本例中。尽管序号为6,7,0.1的数据分组正确到达接收方。但由于5号数据分组误码不被接受,它们也“受到牵连”而不被接受,发送方还要重传这些数据分组,这就是所谓的Go-back-N(回退N帧)。
发送窗口的尺寸不能超过其上限，如在上例，发送窗口为8，则发送01234567，接收方接收完这些后窗口序号为0，这样无法辨认新旧数据分组。...</p></div><footer class=entry-footer><span title='2023-07-14 18:09:28 +0800 CST'>七月 14, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;129 字&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 从零开始的计算机网络3-4" href=https://blog.0pt.im/learn/1-3-4/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>从零开始的计算机网络3-3</h2></header><div class=entry-content><p>差错检测 实际的通信链路都不是理想的，比特在传输过程中可能会产生差错:1可能会变成0,而0也可能变成1。这称为比特差错。
在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER(Bit Error Rate)。使用差错检测码来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。
FCS用于让接收方的数据链路层检查是否产生误码。
奇偶校验 在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中**“1”的个数**为奇数（奇校验)或偶数（偶校验)。
如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码;
如果有偶数个位发生误码，则奇偶性不发生变化，不能检查出误码（漏检)。
漏检率高，计算机网络的数据链路层一般不用奇偶校验。
循环冗余校验CRC(Cyclic Redundancy Check) 收发双方约定好一个生成多项式G(x);
发送方基于待发送的数据和生成多项式计算出差错检测码（冗余码)，将其添加到待传输数据的后面一起传输;
接收方通过生成多项式来计算收到的数据是否产生了误码。
例题：待发送的信息为101001，生成多项式为G(x)= x^3+ x^2+ 1，计算余数。
解析：1.构造被除数 待发送信息后面添加生成多项式最高次数个0
2.构造除数 生成多项式各项系数构成的比特串
3.做“除法”
4.检查余数 余数的位数应与生成多项式最高次数相同，如果位数不够，则在余数前补0来凑足位数。
例题：接收到的信息为101101001，生成多项式为G(x)= x^3 +x^2+l，判断传输是否误码?
解析：1.构造被除数 接收到的信息就是被除数
2.构造除数 生成多项式各项系数构成的比特串
3.做“除法”
4.检查余数 余数为0，可认为传输过程无误码;余数不为0，可认为传输过程产生误码。
检错码只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法纠正错误。
要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。
循环冗余校验CRC有很好的检错能力（漏检率非常低)，虽然计算比较复杂，但非常易于用硬件实现，因此被广泛应用于数据链路层。
在计算机网络中通常采用我们后续中将要讨论的检错重传方式来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务。</p></div><footer class=entry-footer><span title='2023-07-13 18:09:28 +0800 CST'>七月 13, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;42 字&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 从零开始的计算机网络3-3" href=https://blog.0pt.im/learn/1-3-3/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>从零开始的计算机网络3-2</h2></header><div class=entry-content><p>封装成帧 封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。
帧头和帧尾中包含有重要的控制信息。
帧头和帧尾的作用之一就是帧定界。
首尾标志的作用就是帧定界
接收方的链路层可以依据帧定界标志，从物理层交付的比特流中，提取出一个一个的帧。
并不是每种数据链路层的帧都包含有帧定界标志。
使用该协议，物理层会在以太网V2的mac帧前添加前导码。
另外，以太网还规定了帧间间隔时间为96比特的发送时间，不需要帧定界。
透明传输是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样
flag是帧定界标志，是一个特定数值。如图，首位各一个flag，但是在上层交付的协议数据单元中，恰好也包含了这个特定数值，接收方就不能正确接收帧，会提前结束。
解决：在帧发送前，对帧数据部分进行扫描，每出现一个帧定界符，就在其前面插入一个转义字符（ESC）。
接收方在收到转义字符时，会去掉转义字符，并知道后面的不是帧定界符而是数据。
数据部分中出现了转义字符也是同理。
转义字符不是“esc”，而是一个特定字符，十进制值为27.。
面向字节的物理链路使用字节填充（或称字符填充)的方法实现透明传输。
面向比特的物理链路使用比特填充的方法实现透明传输。
在发送前，可采用零比特填充法，每5个连续的比特1前就插入一个比特0，来确保帧定界符的唯一性。接收方接受时把数据部分每5个连续的比特1前的比特0剔除即可。
例题. HDLC协议对 0111110001111110 组帧后对应的比特串为
A.011111000011111010 B.011111000111110101111110
C.01111100011111010 D.011111000111111001111101
解析：高级数据链路控制协议HDLC采用帧头和帧尾中的标志字段作为帧定界符，其值为01111110
HDLC为了实现“透明传输”，采用“零比特填充法”(每5个连续1后面插入一个比特0)，故选A
为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些。
考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU(Maximum Transfer Unit)。</p></div><footer class=entry-footer><span title='2023-07-12 18:09:28 +0800 CST'>七月 12, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;32 字&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 从零开始的计算机网络3-2" href=https://blog.0pt.im/learn/1-3-2/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://blog.0pt.im/zh/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/page/6/>«&nbsp;上一页&nbsp;</a>
<a class=next href=https://blog.0pt.im/zh/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/page/8/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2023 <a href=https://blog.0pt.im/zh/>春风少年兄</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>