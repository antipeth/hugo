<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从零开始的计算机网络3-4 | 春风少年兄</title><meta name=keywords content="计算机网络"><meta name=description content="三.数据链路层"><meta name=author content="Me"><link rel=canonical href=https://blog.0pt.im/learn/1-3-4/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.a7e65f948d47ba4355f19f4d95c472c871278312e92de4f796e75f0c3155eb98.css integrity="sha256-p+ZflI1HukNV8Z9NlcRyyHEngxLpLeT3ludfDDFV65g=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://img.0pt.im/blogbuilt/title.jpeg><link rel=icon type=image/png sizes=16x16 href=https://img.0pt.im/blogbuilt/title.jpeg><link rel=icon type=image/png sizes=32x32 href=https://img.0pt.im/blogbuilt/title.jpeg><link rel=apple-touch-icon href=https://img.0pt.im/blogbuilt/title.jpeg><link rel=mask-icon href=https://img.0pt.im/blogbuilt/title.jpeg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="从零开始的计算机网络3-4"><meta property="og:description" content="三.数据链路层"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.0pt.im/learn/1-3-4/"><meta property="og:image" content="https://blog.0pt.im/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-14T18:09:28+08:00"><meta property="article:modified_time" content="2023-07-14T18:09:28+08:00"><meta property="og:site_name" content="春风少年兄"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.0pt.im/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="从零开始的计算机网络3-4"><meta name=twitter:description content="三.数据链路层"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"从零开始的计算机网络3-4","item":"https://blog.0pt.im/learn/1-3-4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从零开始的计算机网络3-4","name":"从零开始的计算机网络3-4","description":"三.数据链路层","keywords":["计算机网络"],"articleBody":"可靠传输 基本概念 使用差错检测技术（例如循环冗余校验CRC），接收方的数据链路层就可检测传输过程中是否产生了误码（比特错误）。\n数据链路层向上层提供的服务类型\n不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做;\n可靠传输服务：想办法实现发送端发送什么，接收端就收到什么。\n一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。\n无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。\n比特差错只是传输差错中的一种。\n从整个计算机网络体系结构来看，传输差错还包括分组丢失（发送的分组因某种原因被丢弃）、分组失序（发送的多个分组到达接收方的顺序与发送时不同）以及分组重复（分组因网络延时卡在路由器，引发发送方的超时发送，出现重复）。\n分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。\n可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需。\n可靠传输的实现机制——停止-等待协议SW(Stop-and-Wait) 1.确认与否认\nDATA为数据分组，ACK为确认分组，NAK为否认分组。从上往下。\n如该图，接收方发送第一个DATA，接收方对其进行差错，确认无误码，返回ACK，发送方收到ACK后，才可以删除第一个DATA的缓存，发送第二个DATA，若第二个DATA在传输过程中出现误码，接收方对其进行差错，返回NAK，发送方收到NAK，重新发送第二个DATA。（这就是为什么只有收到ACk时才能删除那个数据分组的缓存。）\n2.超时重传\n接收方收不到数据分组，就不会发送ACK或NAK。如果不采取其他措施，发送方就会一直处于等待接收方ACK或NAK的状态。\n为解决该问题，可以在发送方发送完一个数据分组时，启动一个超时计时器。若到了超时计时器所设置的重传时间而发送方仍收不到接收方的任何ACK或NAK，则重传原来的数据分组，这就叫做超时重传。\n一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”\n3.确认分组丢失\nACK丢失，会引起发送方的超时重传。\n为避免分组重复这种传输错误，必须给每个分组带上序号。（如图，DATA0，DATA1）\n对于停止-等待协议，由于每发送一个数据分组就停止等待,只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同就可以了，因此用一个比特来编号就够了。\n4.确认分组迟到\n对确认分组（ACK）进行编号。\nACK0迟到了，导致发送方超时重传，接收方接收到超时重传的DATA0，将其丢弃，并再发送ACK0，发送方接收到重复的ACK0，忽略该确认分组。\n对于数据链路层的点对点信道，往返时间比较固定，不会出现确认分组迟到的情况，因此只在数据链路层实现停止等待协议，不需要给ACK编码。\n注意事项：\n1.接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组\n2.为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。\n3.为了让发送方能够判断所收到的ACK分组是否是重复的，需要给ACK分组编号，所用比特数量与数据分组编号所用比特数量一样。数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。\n4.超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。\n在数据链路层点对点的往返时间比较确定，重传时间比较好设定。\n然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。\n信道利用率\n当往返时延RTT远大于数据帧发送时延To时（例如使用卫星链路)，信道利用率非常低。\n若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低。\n为了克服停止-等待协议信道利用率很低的缺点，就产生了另外两种协议，即后退N帧协议GBN和选择重传协议SR。\n例题：主机甲采用停-等协议向主机乙发送数据，数据传输速率使3kbps，单向传播延时是200ms,忽略确认帧的传输延时。当信道利用率等于40%时，数据帧的长度为\nA.240比特 B.400比特 C.480比特 D.800比特\n解析：\n可靠传输的实现机制——回退N帧协议GBN(Go-Back-N) 采用流水线传输可提高信道利用率。\n1.采用3个比特给分组编序号，即序号0~7; n个比特， 0~2^n -1\n2.发送窗口的尺寸Wt的取值:1","wordCount":"129","inLanguage":"zh","datePublished":"2023-07-14T18:09:28+08:00","dateModified":"2023-07-14T18:09:28+08:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.0pt.im/learn/1-3-4/"},"publisher":{"@type":"Organization","name":"春风少年兄","logo":{"@type":"ImageObject","url":"https://img.0pt.im/blogbuilt/title.jpeg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.0pt.im/zh/ accesskey=h title="世纪大道 (Alt + H)"><img src=https://blog.0pt.im/apple-touch-icon.png alt aria-label=logo height=35>世纪大道</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.0pt.im/zh/search title=找><span>找</span></a></li><li><a href=https://blog.0pt.im/zh/learn/ title=学><span>学</span></a></li><li><a href=https://blog.0pt.im/zh/music/ title=音><span>音</span></a></li><li><a href=https://blog.0pt.im/zh/game/ title=游><span>游</span></a></li><li><a href=https://blog.0pt.im/zh/think/ title=感><span>感</span></a></li><li><a href=https://blog.0pt.im/zh/link/ title=链><span>链</span></a></li><li><a href=https://blog.0pt.im/zh/archives title=时><span>时</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.0pt.im/zh/>主页</a></div><h1 class=post-title>从零开始的计算机网络3-4</h1><div class=post-description>三.数据链路层</div><div class=post-meta><span title='2023-07-14 18:09:28 +0800 CST'>七月 14, 2023</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;129 字&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/antipeth/hugo/content/posts/learn/1-3-4.md rel="noopener noreferrer" target=_blank></a></div></header><div class=post-content><h1 id=可靠传输>可靠传输<a hidden class=anchor aria-hidden=true href=#可靠传输>#</a></h1><h3 id=基本概念>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念>#</a></h3><p>使用<strong>差错检测技术</strong>（例如循环冗余校验CRC），接收方的数据链路层就可检测传输过程中是否产生了<strong>误码</strong>（比特错误）。</p><p>数据链路层向上层提供的服务类型</p><ul><li><p><strong>不可靠传输服务</strong>：<strong>仅仅丢弃有误码的帧</strong>，其他什么也不做;</p></li><li><p><strong>可靠传输服务</strong>：想办法实现<strong>发送端发送什么</strong>，<strong>接收端就收到什么</strong>。</p></li></ul><p>一般情况下，<strong>有线链路</strong>的误码率比较低，为了减小开销，并<strong>不要求数据链路层</strong>向上提供<strong>可靠</strong>传输服务。即使出现了误码，可靠传输的问题由其上层处理。</p><p><strong>无线链路</strong>易受干扰，误码率比较高，因此<strong>要求数据链路层</strong>必须向上层提供<strong>可靠</strong>传输服务。</p><p><strong>比特差错</strong>只是传输差错中的一种。</p><p>从整个计算机网络体系结构来看，传输差错还包括<strong>分组丢失</strong>（发送的分组因某种原因被丢弃）、<strong>分组失序</strong>（发送的多个分组到达接收方的顺序与发送时不同）以及<strong>分组重复</strong>（分组因网络延时卡在路由器，引发发送方的超时发送，出现重复）。</p><p>分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-2.png alt></p><p>可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需。</p><h3 id=可靠传输的实现机制停止-等待协议swstop-and-wait>可靠传输的实现机制——停止-等待协议SW(Stop-and-Wait)<a hidden class=anchor aria-hidden=true href=#可靠传输的实现机制停止-等待协议swstop-and-wait>#</a></h3><p>1.确认与否认</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-1.png alt></p><p><strong>DATA为数据分组，ACK为确认分组，NAK为否认分组。从上往下。</strong></p><p>如该图，接收方发送第一个DATA，接收方对其进行差错，确认无误码，返回ACK，发送方收到ACK后，才可以删除第一个DATA的缓存，发送第二个DATA，若第二个DATA在传输过程中出现误码，接收方对其进行差错，返回NAK，发送方收到NAK，重新发送第二个DATA。（这就是为什么只有收到ACk时才能删除那个数据分组的缓存。）</p><p>2.超时重传</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-3.png alt></p><p>接收方收不到数据分组，就不会发送ACK或NAK。如果不采取其他措施，发送方就会一直处于等待接收方ACK或NAK的状态。</p><p>为解决该问题，可以在发送方发送完一个数据分组时，启动一个<strong>超时计时器</strong>。若到了超时计时器所设置的<strong>重传时间</strong>而发送方仍收不到接收方的任何ACK或NAK，则重传原来的数据分组，这就叫做<strong>超时重传</strong>。</p><p>一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”</p><p>3.确认分组丢失</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-4.png alt></p><p>ACK丢失，会引起发送方的超时重传。</p><p>为避免分组重复这种传输错误，必须给每个分组带上序号。（如图，DATA0，DATA1）</p><p>对于停止-等待协议，由于每发送一个数据分组就停止等待,只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同就可以了，因此用一个比特来编号就够了。</p><p>4.确认分组迟到</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-5.png alt></p><p>对确认分组（ACK）进行编号。</p><p>ACK0迟到了，导致发送方超时重传，接收方接收到超时重传的DATA0，将其丢弃，并再发送ACK0，发送方接收到重复的ACK0，忽略该确认分组。</p><blockquote><p>对于数据链路层的点对点信道，往返时间比较固定，不会出现确认分组迟到的情况，因此只在数据链路层实现停止等待协议，不需要给ACK编码。</p></blockquote><p>注意事项：</p><p>1.接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组</p><p>2.为了让接收方能够判断所收到的数据分组是否是重复的，需要给<strong>数据分组编号</strong>。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。</p><p>3.为了让发送方能够判断所收到的ACK分组是否是重复的，需要给<strong>ACK分组编号</strong>，所用比特数量<strong>与数据分组编号</strong>所用比特数量一样。数据链路层一般不会出现ACK分组迟到的情况，因此在<strong>数据链路层实现停止-等待协议可以不用给ACK分组编号</strong>。</p><p>4.超时计时器设置的<strong>重传时间</strong>应仔细选择。一般可将重传时间选为<strong>略大于“从发送方到接收方的平均往返时间”</strong>。</p><ul><li><p>在数据链路层点对点的往返时间比较确定，重传时间比较好设定。</p></li><li><p>然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。</p></li></ul><p>信道利用率</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-6.png alt></p><p><strong>当往返时延RTT远大于数据帧发送时延To时（例如使用卫星链路)，信道利用率非常低。</strong></p><p>若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低。</p><p>为了克服停止-等待协议信道利用率很低的缺点，就产生了另外两种协议，即后退N帧协议GBN和选择重传协议SR。</p><p>例题：主机甲采用停-等协议向主机乙发送数据，数据传输速率使3kbps，单向传播延时是200ms,忽略确认帧的传输延时。当信道利用率等于40%时，数据帧的长度为</p><p>A.240比特 B.400比特 C.480比特 D.800比特</p><p>解析：</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-7.png alt></p><h3 id=可靠传输的实现机制回退n帧协议gbngo-back-n>可靠传输的实现机制——回退N帧协议GBN(Go-Back-N)<a hidden class=anchor aria-hidden=true href=#可靠传输的实现机制回退n帧协议gbngo-back-n>#</a></h3><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-8.png alt></p><p>采用流水线传输可提高信道利用率。</p><p>1.采用3个比特给分组编序号，即序号0~7; n个比特， 0~2^n -1</p><p>2.发送窗口的尺寸Wt的取值:1&lt;Wt≤2^3 - 1，本例取Wt=5. 1&lt;Wr&lt;2^n -1</p><p>3.接收窗口的尺寸Wr的取值:Wr=1;</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-9.png alt></p><p>发送窗口一次发送5个</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-10.png alt></p><p>到达接收方，接收窗口依次一个分组一个分组识别，并依次发回确认分组。</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-11.png alt></p><p>发送方每接受一个确认分组，发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口。</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-12.png alt></p><p>发送方可以把收到确认的分组从缓存中删除了，而接收方可以择机将已接收的数据交付上层处理。</p><p>累积确认</p><p>接收方<strong>不一定</strong>要对收到的数据分组<strong>逐个发送确认</strong>，而是可以在收到几个数据分组后（由具体实现决定)<strong>对按序到达的最后一个数据分组发送确认</strong>。ACKn表示序号为n及以前的所有数据分组都已正确接收。</p><p>如上图，接收方接收到0-1，发送一个ACK1，处理完2-4，发送一个ACK4，若ACK1丢了，ACK4到达发送方，则表明分组0-4都确认，已正确接收。</p><p>缺点</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-13.png alt></p><p>5号出现误码，丢弃，而后的序号6701，无法被5号接收窗口接收，也只能丢弃，每丢弃一个数据分组（5号误码不算），返回之前按序接受的最后一个确认分组，在本例中是ACK4，发4个ACK4。</p><p>发送方收到重复的确认。就知道之前所发送的数据分组出现了差错,于是可以不等超时计时器超时就立刻重传!</p><p>至于收到几个重复确认就立刻重传,由具体实现决定。若不能触发立刻重传，则等待超时计时器。超时后将发送窗口中的分组重传。</p><p><strong>在本例中。尽管序号为6,7,0.1的数据分组正确到达接收方。但由于5号数据分组误码不被接受,它们也“受到牵连”而不被接受,发送方还要重传这些数据分组,这就是所谓的Go-back-N(回退N帧)。</strong></p><p>发送窗口的尺寸不能超过其上限，如在上例，发送窗口为8，则发送01234567，接收方接收完这些后窗口序号为0，这样无法辨认新旧数据分组。</p><p>小结</p><p>发送方</p><ul><li><p>发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去;</p></li><li><p>发送方只有收到对已发送数据分组的确认时，发送窗口才能向前相应滑动;</p></li><li><p>发送方收到多个重复确认时，可在重传计时器超时前尽早开始重传，由具体实现决定。</p></li><li><p>发送方发送窗口内某个已发送的数据分组产生超时重发时，其后续在发送窗口内且已发送的数据分组也必须全部重传，这就是回退N帧协议名称的由来。</p></li></ul><p>接收方</p><ul><li><p>接收方的接收窗口尺寸取值是1因此接收方只能按序接收数据分组。</p></li><li><p>接收方只接收序号落在接收窗口内且无误码的数据分组，并且将接收窗口向前滑动一个位置，与此同时给发送方发回相应的确认分组。</p></li><li><p>为了减少开销，接收方不一定每收到一个按序到达且无误码的数据分组就给发送方发回一个确认分组,而是可以在连续收到好几个按序到达且无误码的数据分组后(由具体实现决定)，才针对最后一个数据分组发送确认分组，这称为累积确认;</p></li><li><p>或者可以在自己有数据分组要发送时才对之前按序接收且无误码的数据分组进行捎带确认;</p></li><li><p>接收方收到未按序到达的数据分组，除丢弃外，还要对最近按序接收的数据分组进行确认;</p></li></ul><p>例题：数据链路层使用后退N帧(GBN)协议，发送方已经发送了编号为0~7的帧。送方只收到0、2、3号帧的确认，则发送方需要重发的帧数是</p><p>A.2 B.3 C.4 D.5</p><p>解析：</p><p>(1)“发送方只收到0、2、3号帧的确认”表明接收方正确接收了0~3号帧，并针对它们中的每一个发送了确认帧,只不过针对1号帧的确认帧丢失了(这是题目中的陷阱，但又没有相应的选项，所以迷惑性并不是很大);</p><p>(2)截止到计时器超时，发送方只收到了针对0~3号帧的确认，而发送方之前已经发送了0~7号帧，因此应该从4号帧开始重传，即重传之前已经发送过的4、5、6、7号帧，共计重传4个帧。</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-14.png alt></p><p>一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接收而丢弃（尽管它们无乱序和误码)。这必然会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费。</p><h3 id=可靠传输的实现机制选择重传协议srselective-request>可靠传输的实现机制——选择重传协议SR(Selective Request)<a hidden class=anchor aria-hidden=true href=#可靠传输的实现机制选择重传协议srselective-request>#</a></h3><p>为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸<strong>不应再等于1(而应大于1)</strong>，以便<strong>接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组</strong>，等到所缺分组收齐后再一并送交上层。这就是<strong>选择重传协议</strong>。</p><p>注意:</p><p><strong>选择重传协议</strong>为了使发送方仅重传出现差错的分组，接收方<strong>不能再采用累积确认</strong>，而需要对每个正确接收到的数据分组进行<strong>逐一确认</strong>!</p><p>1.采用3个比特给分组编序号，即序号0~7; n个比特 0~2^n - 1</p><p>2.发送窗口的尺寸Wt的取值:1&lt;wt&lt;=(2^3-1)，本例取Wt=4 1&lt;Wt&lt;2^(n-1)</p><p>3.接收窗口的尺寸Wr的取值:Wr=Wt=4;</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-15.png alt></p><p>发送方发送了0、1、2、3这4个序号的分组，在传输过程中，序号2的分组丢失</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-16.png alt></p><p>接收方接受了0、1、3这3个分组，先接受0、1这2个（这2个数据分组<strong>按序到达</strong>），并返回相应的1、2确认分组此时接收窗口向前移动2位，4和5落在接收窗口的位置。然后接受3这个分组，并返回3确认分组。但是此时接收窗口不能向前移动，因为3号数据分组是<strong>未按序到达</strong>的数据分组。</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-17.png alt></p><p>发送窗口先接收0、1确认分组，此时发送窗口向前移动2位，4、5落在发送窗口的位置，然后发送4、5数据分组，此时发送方可将0、1数据分组从发送缓存删除。接收方可择机将已接收的数据交付上层处理。</p><p>然后发送窗口再接收3号确认分组，知道3号数据分组已成功接收，之后3号数据并不会重复发送。但发送窗口不能向前移动，因为3号确认分组是<strong>未按序到达</strong>的数据分组。</p><p>而后，若4、5数据分组到达接收方后，接收窗口也不能向前移动，其他操作同理。</p><p>等发送方针对2号数据分组的重传计时器超时了，发送方就会重传2号数据分组。</p><p>发送窗口超过范围会造成无法辨识新旧数据分组</p><p><img loading=lazy src=https://img.0pt.im/computernet/3-4/3-4-18.png alt></p><p>发送方发送0、1、2、3、4数据分组，接收方接收后返回0、1、2、3、4确认分组。然后0号确认分组丢了，1、2、3、4确认分组正常接收，此时发送窗口不能向前移动。然后等发送方针对0号数据分组的重传计时器超时了，发送方就会重传0号数据分组，此时0号数据分组会匹配到第二组循环序号的0号当中，无法辨识新旧数据分组，出现分组重复。</p><p>小结</p><p>发送方</p><ul><li><p>发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去;</p></li><li><p>发送方只有按序收到对已发送数据分组的确认时，发送窗口才能向前相应滑动;若收到未按序到达的确认分组时，对其进行记录，以防止其相应数据分组的超时重发，但发送窗口不能向前滑动。</p></li></ul><p>接收方</p><ul><li><p>接收方可接收未按序到达但没有误码并且序号落在接收窗口内的数据分组;</p></li><li><p>为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的数据分组进行逐一确认!</p></li><li><p>接收方只有在按序接收数据分组后，接收窗口才能向前相应滑动。</p></li></ul><p>例题：数据链路层采用选择重传协议(SR)）传输数据，发送方已发送了0~3号数据帧，现已收到1号帧的确认，而0、2号帧依次超时，则此时需要重传的帧数是</p><p>A.1 B.2 C.3 D.4</p><p>解析：</p><p>(1)与回退N帧协议不同，选择重传协议不支持累积确认。接收方每接收一个数据帧，就会发回相应的确认帧。</p><p>(2）题目所给“收到1号帧的确认，而0、2号帧依次超时”，因此需要重传O、2号帧。至于发送方已发送的3号数据帧，题目并未给出它的任何其他线索，因此无须考虑3号帧。</p><p>故选B</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.0pt.im/zh/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>计算机网络</a></li></ul><nav class=paginav><a class=prev href=https://blog.0pt.im/learn/1-3-5/><span class=title>« 上一页</span><br><span>从零开始的计算机网络3-5</span></a>
<a class=next href=https://blog.0pt.im/learn/1-3-3/><span class=title>下一页 »</span><br><span>从零开始的计算机网络3-3</span></a></nav></footer><style>.comments_details summary::marker{font-size:20px;content:'👉展开评论';color:var(--content)}.comments_details[open] summary::marker{font-size:20px;content:'👇关闭评论';color:var(--content)}</style><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://cdn.staticfile.org/twikoo/1.6.16/twikoo.all.min.js></script>
<script>twikoo.init({envId:"https://twikoo-ten-pearl.vercel.app/",el:"#tcomment",lang:"zh-CN",region:"",path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.0pt.im/zh/>春风少年兄</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>